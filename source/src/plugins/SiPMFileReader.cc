/// \file SiPMFileReader.cc
/*
 *
 * SiPMFileReader.cc source template automatically generated by a class generator
 * Creation date : lun. mars 7 2016
 *
 * This file is part of DQM4HEP libraries.
 *
 * DQM4HEP is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 *
 * DQM4HEP is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with DQM4HEP.  If not, see <http://www.gnu.org/licenses/>.
 *
 * @author Tom Coates
 * @copyright CNRS , IPNL
 */

// -- dqm4hep headers
#include <dqm4hep/Event.h>
#include <dqm4hep/EventReader.h>
#include <dqm4hep/StatusCodes.h>
#include <dqm4hep/GenericEvent.h>
#include <dqm4hep/PluginManager.h>
#include <dqm4hep/XmlHelper.h>

namespace dqm4hep {

  namespace core {

    /**
     *  @brief  SiPMFileReader class
     *          Read a DREAM SiPM txt datafile and read GenericEvent events from it
     */
    class SiPMFileReader : public EventReader {
    public:
      SiPMFileReader() = default;
      ~SiPMFileReader() override;
      SiPMFileReader(const SiPMFileReader&) = delete;
      SiPMFileReader& operator=(const SiPMFileReader&) = delete;

      core::StatusCode open(const std::string &fname) override;
      core::StatusCode skipNEvents(int nEvents) override;
      core::StatusCode runInfo(core::Run &run) override;
      core::StatusCode readNextEvent() override;
      core::StatusCode close() override;
      
    protected:
      std::istringstream headerStream;
      std::istringstream dataStream;

    private:
      TiXmlDocument        m_document = {};               // Do we need these? We're not loading in an actual document
      TiXmlElement        *m_currentEvent = {nullptr};    // Do we need these? We're not loading in an actual document
    };
    
    //-------------------------------------------------------------------------------------------------
    //-------------------------------------------------------------------------------------------------

    SiPMFileReader::~SiPMFileReader() {
      //
    }

    //-------------------------------------------------------------------------------------------------

    StatusCode DreamSiPMReader::open(const std::string &fname) {

      std::FILE *p_dataFile = std::fopen(fname, "rb");
      bool isFileOpenable = p_dataFile;

      if(!isFileOpenable) {
	dqm_error("The file at {0} could not be opened.", fname);
	throw StatusCodeException(STATUS_CODE_FAILURE);
      }

      std::string rawData;
      std::fseek(p_dataFile, 0, SEEK_END);
      rawData.resize(std::ftell(p_dataFile));
      std::rewind(p_dataFile);
      std::fread(&rawData[0], 1, rawData.size(), p_dataFile);
      std::fclose(p_dataFile);

      std::string headerTagOpen  = "<ACQUISITION_INFO>";
      std::string headerTagClose = "</ACQUISITION_INFO>";
      std::string dataTagStart   = "</START_NOTE>";

      int headerStartPos = rawData.find(headerTagOpen);
      int headerEndPos   = rawData.find(headerTagOpen) + headerTagOpen.size() - headerStartPos;
      int dataStartPos   = rawData.find(dataTagStart)  + dataTagStart.size();

      headerStream = rawData.substr(headerStart, headerEnd); // We also want to store this as a parseable XML object
      dataSteam    = rawData.substr(dataStartPos);

      return STATUS_CODE_SUCCESS;
    }

    //-------------------------------------------------------------------------------------------------

    StatusCode DreamSiPMReader::skipNEvents(int nEvents) {

      for (int e=0; e<nEvents; e++) {
	std::string currentEventString;
	std::getline(dataStream, currentEventString);
	currentEventString.clear();
      }

      return STATUS_CODE_SUCCESS;
    }

    //-------------------------------------------------------------------------------------------------

    StatusCode DreamSiPMReader::runInfo(core::Run &run) {

      // So what this needs to do is parse headerStream as XML, to extract the important information, then place it into the runInfo container.

      runInfo.setRunNumber();
      runInfo.setDetectorName();
      runInfo.setStartTime();
      // other run info:
      //   temperature
      //   datetime
      //   temperature2
      //   bias
      //   detector board
      //   detector model
      //   detector SN
      //   detector VOP
      //   acquisition board sn
      //   acquisition board RC
      //   board count
      //   board 1 id
      //   board 2 id
      // config info:
      //   trigger mode
      //   trigger level
      //   data delay 1
      //   trigger delay 1
      //   data delay 2
      //   trigger delay 2
      //   trigger hold
      //   polarity
      //   pileup rejector
      //   pileup time
      //   integration time
      //   baseline correction
      //   baseline constant
      //   noise filter
      //   digital gain
      //   correlated board

      return STATUS_CODE_SUCCESS;
    }

    //-------------------------------------------------------------------------------------------------

    StatusCode DreamSiPMReader::readNextEvent() {
      EventPtr event = GenericEvent::make_shared();
      GenericEvent *generic = event->getEvent<GenericEvent>();

      std::vector<float> eventContainer;
      std::string eventDelimiter = ";";
      std::string currentEventString;

      std::getline(dataStream, currentEventString);

      if (currentEventString.size() <= 1) {
	dqm_warning("Event is blank");
	return STATUS_CODE_SUCCESS;
      }
  
      dqm4hep::core::tokenize(currentEventString, eventContainer, eventDelimiter);
  
      if (eventContainer.size() != 66) { // This might change based on number of actual members?
	dqm_error("Event has wrong number of members");
	throw StatusCodeException(STATUS_CODE_FAILURE);
      } 

      std::vector<float> ev_eventNum = {eventContainer[0]}
      generic->setValues("Event", ev_eventNum);
      eventContainer.erase[0];

      std::vector<float> ev_time = {eventContainer[0]}
      generic->setValues("Time", ev_time);
      eventContainer.erase[0];
  
      generic->setValues("Channels", eventContainer);
      
      onEventRead().emit(event);
      return STATUS_CODE_SUCCESS;
    }

    StatusCode DreamSiPMReader::close() {

      // We already close the file in DreamSiPMReader::open(), so we don't need to close it here.
      // Moreover, we *can't* really close it here anyway, since it will go out of scope once open() returns.

      // So what do we need to do here, if anything?

      return STATUS_CODE_SUCCESS;
    }

    //-------------------------------------------------------------------------------------------------
    
    DQM_PLUGIN_DECL(SiPMFileReader, "SiPMFileReader");
  }
}
